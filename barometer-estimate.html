<script>
  function $(id){ return document.getElementById(id); }
  function estimatePressure(elevM) {
    const P0 = 1013.25; // hPa
    return (P0 * Math.pow(1 - (0.0065 * elevM) / 288.15, 5.255)).toFixed(2);
  }

  async function fetchJSON(url, opts = {}) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), opts.timeoutMs ?? 8000);
    try {
      const res = await fetch(url, { signal: controller.signal });
      const text = await res.text(); // capture raw for error visibility
      let data;
      try { data = JSON.parse(text); } catch { data = { _raw: text }; }
      return { ok: res.ok, status: res.status, data };
    } finally {
      clearTimeout(t);
    }
  }

  async function getElevation(lat, lon) {
    const candidates = [
      { name: 'OpenTopoData srtm90m', url: `https://api.opentopodata.org/v1/srtm90m?locations=${lat},${lon}`,
        parse: d => (d && d.status === 'OK' && d.results?.[0]?.elevation) ?? null },
      { name: 'OpenTopoData gmted2010', url: `https://api.opentopodata.org/v1/gmted2010?locations=${lat},${lon}`,
        parse: d => (d && d.status === 'OK' && d.results?.[0]?.elevation) ?? null },
      { name: 'Open-Meteo elevation', url: `https://api.open-meteo.com/v1/elevation?latitude=${lat}&longitude=${lon}`,
        parse: d => (typeof d?.elevation === 'number' ? d.elevation : (Array.isArray(d?.elevation) ? d.elevation[0] : null)) }
    ];

    const errors = [];
    for (const c of candidates) {
      const r = await fetchJSON(c.url);
      if (r.ok) {
        const elev = c.parse(r.data);
        if (typeof elev === 'number' && isFinite(elev)) {
          return { elevationMeters: elev, source: c.name };
        } else {
          errors.push(`${c.name}: OK ${r.status} but no elevation (payload: ${JSON.stringify(r.data).slice(0,200)}…)`);
        }
      } else {
        errors.push(`${c.name}: HTTP ${r.status} (payload: ${JSON.stringify(r.data).slice(0,200)}…)`);
      }
    }
    throw new Error(errors.join(' | '));
  }

  async function getPressureEstimate() {
    const latEl = $('latitude'), lonEl = $('longitude'),
          elevEl = $('elevation'), presEl = $('pressure'), statusEl = $('status');

    const set = (el, txt) => el && (el.textContent = txt);

    if (!navigator.geolocation) {
      set(statusEl, 'Geolocation not supported.');
      return;
    }
    if (!navigator.onLine) {
      set(statusEl, 'Offline: check your connection.');
      return;
    }

    set(statusEl, 'Requesting location…');

    navigator.geolocation.getCurrentPosition(async (pos) => {
      const lat = pos.coords.latitude.toFixed(5);
      const lon = pos.coords.longitude.toFixed(5);
      set(latEl, lat); set(lonEl, lon);
      set(statusEl, 'Fetching elevation…');

      try {
        const { elevationMeters, source } = await getElevation(lat, lon);
        const elevationFeet = Math.round(elevationMeters * 3.28084);
        const pressure = estimatePressure(elevationMeters);
        set(elevEl, `${elevationFeet} ft`);
        set(presEl, `${pressure} hPa`);
        set(statusEl, `Done via ${source}.`);
      } catch (err) {
        console.error(err);
        set(statusEl, `Failed to retrieve elevation: ${err.message}`);
      }
    }, (err) => {
      console.error(err);
      const map = {
        1: 'Permission denied',
        2: 'Position unavailable',
        3: 'Request timeout'
      };
      set(statusEl, `Location error: ${map[err.code] || 'Unknown'} (${err.code})`);
    }, {
      enableHighAccuracy: true,
      maximumAge: 0,
      timeout: 10000
    });
  }
</script>
